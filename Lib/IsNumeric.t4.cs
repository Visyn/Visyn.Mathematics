#region Copyright (c) 2015-2017 Visyn
//The MIT License(MIT)
//
//Copyright(c) 2015-2017 Visyn
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:

//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.

//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.
#endregion
#region Autogenerated T4 Text Template
// Autogenerated from T4 Text Template :	IsNumeric.tt
//											file:\C:\git\proto.temp\Visyn.Mathematics\Lib\IsNumeric.tt
// Autogeneration date/time:				8/14/2017 7:37:11 PM
#endregion
using System;
using Visyn.Mathematics;

using System.Reflection;
using Visyn.Types;

namespace Visyn.Mathematics
{

	public static class IsNumericType
	{
	
	    /// <summary>
        /// Determines whether the specified item is a numeric data type.
        /// </summary>
        /// <param name="type">The item</param>
        /// <returns><c>true</c> if the specified item is numeric; otherwise, <c>false</c>.</returns>
		public static bool IsNumeric(this object item) 
		{
	        if (item == null) return false;
	        var type = item.GetType();
	        if (type.GetTypeInfo().IsValueType) return type.IsNumeric();

	        var genericType = Nullable.GetUnderlyingType(type);
	        if (genericType != null)
	        {
#if DEBUG
                throw new Exception("Look into this case more....");
#else
                return genericType.IsNumeric();
#endif
	        }
	        var itype = item as Visyn.Types.IType;
	        if (itype != null) return itype.Type.IsNumeric();

	        return false;
		}

		/// <summary>
        /// Determines whether the specified item is a numeric data type.
        /// </summary>
        /// <param name="type">The item</param>
        /// <returns><c>true</c> if the specified item is numeric; otherwise, <c>false</c>.</returns>
		public static bool IsNumericExtended(this object item) 
		{
	        if (item == null) return false;
	        var type = item.GetType();
	        if (type.GetTypeInfo().IsValueType) return type.IsNumericExtended();

	        var genericType = Nullable.GetUnderlyingType(type);
	        if (genericType != null)
	        {
#if DEBUG
                throw new Exception("Look into this case more....");
#else
                return genericType.IsNumericExtended();
#endif
	        }
	        var itype = item as Visyn.Types.IType;
	        if (itype != null) return itype.Type.IsNumericExtended();

	        return false;
		}

		/// <summary>
        /// Gets the type of item if the item is numeric.
        /// </summary>
        /// <param name="item">The item.</param>
        /// <returns>A valid numeric type, or null if non-numeric</returns>
		public static Type GetNumericType(this object item)
		{
			if (item == null) return null;
		    var type = item.GetType();
			// Int32 
			if (type == typeof(Int32)) return typeof(Int32);
			// Int64 
			if (type == typeof(Int64)) return typeof(Int64);
			// Int16 
			if (type == typeof(Int16)) return typeof(Int16);
			// Char 
			if (type == typeof(Char)) return typeof(Char);
			// UInt32 
			if (type == typeof(UInt32)) return typeof(UInt32);
			// UInt64 
			if (type == typeof(UInt64)) return typeof(UInt64);
			// UInt16 
			if (type == typeof(UInt16)) return typeof(UInt16);
			// Byte 
			if (type == typeof(Byte)) return typeof(Byte);
			// Double 
			if (type == typeof(Double)) return typeof(Double);
			// Single 
			if (type == typeof(Single)) return typeof(Single);
			// Decimal 
			if (type == typeof(Decimal)) return typeof(Decimal);
		    var value = item as IValue;
		    if(value != null && value.Type.IsNumeric()) return value.Type;
			return null;
		}

				/// <summary>
        /// Gets the type of item if the item is numeric.
        /// </summary>
        /// <param name="item">The item.</param>
        /// <returns>A valid numeric type, or null if non-numeric</returns>
		public static Type GetExtendedNumericType(this object item)
		{
			if (item == null) return null;
		    var type = item.GetType();
			// Int32 
			if (type == typeof(Int32)) return typeof(Int32);
			// Int64 
			if (type == typeof(Int64)) return typeof(Int64);
			// Int16 
			if (type == typeof(Int16)) return typeof(Int16);
			// Char 
			if (type == typeof(Char)) return typeof(Char);
			// UInt32 
			if (type == typeof(UInt32)) return typeof(UInt32);
			// UInt64 
			if (type == typeof(UInt64)) return typeof(UInt64);
			// UInt16 
			if (type == typeof(UInt16)) return typeof(UInt16);
			// Byte 
			if (type == typeof(Byte)) return typeof(Byte);
			// Double 
			if (type == typeof(Double)) return typeof(Double);
			// Single 
			if (type == typeof(Single)) return typeof(Single);
			// Decimal 
			if (type == typeof(Decimal)) return typeof(Decimal);
			// DateTime 
			if (type == typeof(DateTime)) return typeof(DateTime);
			// TimeSpan 
			if (type == typeof(TimeSpan)) return typeof(TimeSpan);
			// Boolean 
			if (type == typeof(Boolean)) return typeof(Boolean);
		    var value = item as IValue;
		    if(value != null && value.Type.IsNumeric()) return value.Type;
			return null;
		}

		[Obsolete("Do not use.  Reference only", true)]
		public static Type GetGenericType2(this Type type) { return Nullable.GetUnderlyingType(type); }

		[Obsolete("Do not use.  Reference only", true)]
        public static bool IsGenericType2(this Type type) { return type.GetTypeInfo().IsGenericType; }


		/// <summary>
        /// Determines whether the specified type is a numeric data type.
        /// </summary>
        /// <param name="type">The type</param>
        /// <returns><c>true</c> if the specified type is numeric; otherwise, <c>false</c>.</returns>
		public static bool IsNumeric(this Type type)
        {

			// Int32 
			if (type == typeof(Int32)) return true;
			// Int64 
			if (type == typeof(Int64)) return true;
			// Int16 
			if (type == typeof(Int16)) return true;
			// Char 
			if (type == typeof(Char)) return true;
			// UInt32 
			if (type == typeof(UInt32)) return true;
			// UInt64 
			if (type == typeof(UInt64)) return true;
			// UInt16 
			if (type == typeof(UInt16)) return true;
			// Byte 
			if (type == typeof(Byte)) return true;
			// Double 
			if (type == typeof(Double)) return true;
			// Single 
			if (type == typeof(Single)) return true;
			// Decimal 
			if (type == typeof(Decimal)) return true;
            // If type is generic type
		    var genericType = Nullable.GetUnderlyingType(type);
            return genericType != null && genericType.IsNumeric();
		}

		/// <summary>
        /// Determines whether the specified type is a numeric data type.
        /// </summary>
        /// <param name="type">The type</param>
        /// <returns><c>true</c> if the specified type is numeric; otherwise, <c>false</c>.</returns>
		public static bool IsNumericExtended(this Type type)
        {

			// Int32 
			if (type == typeof(Int32)) return true;
			// Int64 
			if (type == typeof(Int64)) return true;
			// Int16 
			if (type == typeof(Int16)) return true;
			// Char 
			if (type == typeof(Char)) return true;
			// UInt32 
			if (type == typeof(UInt32)) return true;
			// UInt64 
			if (type == typeof(UInt64)) return true;
			// UInt16 
			if (type == typeof(UInt16)) return true;
			// Byte 
			if (type == typeof(Byte)) return true;
			// Double 
			if (type == typeof(Double)) return true;
			// Single 
			if (type == typeof(Single)) return true;
			// Decimal 
			if (type == typeof(Decimal)) return true;
			// DateTime 
			if (type == typeof(DateTime)) return true;
			// TimeSpan 
			if (type == typeof(TimeSpan)) return true;
			// Boolean 
			if (type == typeof(Boolean)) return true;
            // If type is generic type
		    var genericType = Nullable.GetUnderlyingType(type);
            return genericType != null && genericType.IsNumericExtended();
		}

		/// <summary>
        /// Determines whether the specified type is a signed numeric data type.
        /// </summary>
        /// <param name="type">The type</param>
        /// <returns><c>true</c> if the specified type is a signed numeric type; otherwise, <c>false</c>.</returns>
		public static bool IsSignedNumeric(this Type type)
        {
			// Int32 
			if (type == typeof(Int32)) return true;
			// Int64 
			if (type == typeof(Int64)) return true;
			// Int16 
			if (type == typeof(Int16)) return true;
			// Char 
			if (type == typeof(Char)) return true;
			// Double 
			if (type == typeof(Double)) return true;
			// Single 
			if (type == typeof(Single)) return true;
			// Decimal 
			if (type == typeof(Decimal)) return true;
            // If type is generic type
		    var genericType = Nullable.GetUnderlyingType(type);
            return genericType != null && genericType.IsSignedNumeric();
		}

		/// <summary>
        /// Determines whether the specified type is an unsigned numeric data type.
        /// </summary>
        /// <param name="type">The type</param>
        /// <returns><c>true</c> if the specified type is unsigned numeric; otherwise, <c>false</c>.</returns>
		public static bool IsUnsignedNumeric(this Type type)
        {
			// UInt32 
			if (type == typeof(UInt32)) return true;
			// UInt64 
			if (type == typeof(UInt64)) return true;
			// UInt16 
			if (type == typeof(UInt16)) return true;
			// Byte 
			if (type == typeof(Byte)) return true;
		    var genericType = Nullable.GetUnderlyingType(type);
            return genericType != null && genericType.IsUnsignedNumeric();
		}

		public static bool IsZero(this object item)
        {
		    var type = item?.GetType();
	        if (type == null) return false;
			// Int32 
			if (type == typeof(Int32)) return  ((Int32)item) == 0;
			// Int64 
			if (type == typeof(Int64)) return  ((Int64)item) == 0;
			// Int16 
			if (type == typeof(Int16)) return  ((Int16)item) == 0;
			// Char 
			if (type == typeof(Char)) return  ((Char)item) == 0;
			// UInt32 
			if (type == typeof(UInt32)) return  ((UInt32)item) == 0;
			// UInt64 
			if (type == typeof(UInt64)) return  ((UInt64)item) == 0;
			// UInt16 
			if (type == typeof(UInt16)) return  ((UInt16)item) == 0;
			// Byte 
			if (type == typeof(Byte)) return  ((Byte)item) == 0;
						// Double 
			if (type == typeof(Double)) return  ((Double)item) == ((Double)0);
			// Single 
			if (type == typeof(Single)) return  ((Single)item) == ((Single)0);
			// Decimal 
			if (type == typeof(Decimal)) return  ((Decimal)item) == ((Decimal)0);
			if (type == typeof(DateTime)) return ((DateTime)item) == DateTime.MinValue;
			if (type == typeof(TimeSpan)) return ((TimeSpan)item) == TimeSpan.Zero;
			if (type == typeof(bool)) return ((bool)item) == false;

			var itype = item as Visyn.Types.IType;
			if(itype != null)
			{
			    if (itype.IsNumeric())
			    {
			        var value = item as Visyn.Types.IValue;
                    if(value != null)
                    { 
                        return value.ValueAsObject().IsZero();
                    }

                    throw new Exception("Not sure how to handle this case");
			    }
			}
			if(type.GetTypeInfo().IsGenericType)
			{
			    var nullableType = Nullable.GetUnderlyingType(type);
                if(nullableType != null)
                {
                    if(!nullableType.IsNumeric())
                    {
                        return false;
                    }

                    throw new Exception("Not sure how to handle this case");
                }
			}
			return false;
		}
	}
}