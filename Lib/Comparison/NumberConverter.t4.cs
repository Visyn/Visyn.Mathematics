#region Copyright (c) 2015-2018 Visyn
//The MIT License(MIT)
//
//Copyright (c) 2015-2018 Visyn
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:

//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.

//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.
#endregion
#region Autogenerated T4 Text Template
// Autogenerated from T4 Text Template :	NumberConverter.tt
//											file:\C:\git\proto.temp\Visyn.Mathematics\Lib\Comparison\NumberConverter.tt
// Autogeneration date/time:				8/14/2017 7:36:40 PM
#endregion
using System;
using Visyn.Mathematics;

using System.Diagnostics;
using Visyn.Types;
using Visyn.Comparison;
using Visyn.Exceptions;

namespace Visyn.Mathematics.Comparison 
{	
	public partial class NumberConverter : INumberConverter
			, INumberConverterExtended<Int32>, INumberConverterExtended<Int64>, INumberConverterExtended<Int16>, INumberConverterExtended<Char>, INumberConverterExtended<Double>, INumberConverterExtended<Single>, INumberConverterExtended<Decimal>
			, INumberConverterExtended<UInt32>, INumberConverterExtended<UInt64>, INumberConverterExtended<UInt16>, INumberConverterExtended<Byte>
	{
	    private static NumberConverter _instance;

	    public static NumberConverter Instance => _instance ?? (_instance = new NumberConverter());

		protected NumberConverter() { }

#region Int32 		// Int32 
			public Int32 ToInt32(object a) 
			{
			    if (a == null) return (Int32) 0;
				Type type = a.GetType();
				if(a is IValue)
				{
					type = ((IValue)a).Type;
					a = ((IValue)a).ValueAsObject();
				}

                if (type == typeof(Int32)) return ((INumberConverter<Int32>)this).ToInt32((Int32)a);
                if (type == typeof(Int64)) return ((INumberConverter<Int64>)this).ToInt32((Int64)a);
                if (type == typeof(Int16)) return ((INumberConverter<Int16>)this).ToInt32((Int16)a);
                if (type == typeof(Char)) return ((INumberConverter<Char>)this).ToInt32((Char)a);
                if (type == typeof(UInt32)) return ((INumberConverter<UInt32>)this).ToInt32((UInt32)a);
                if (type == typeof(UInt64)) return ((INumberConverter<UInt64>)this).ToInt32((UInt64)a);
                if (type == typeof(UInt16)) return ((INumberConverter<UInt16>)this).ToInt32((UInt16)a);
                if (type == typeof(Byte)) return ((INumberConverter<Byte>)this).ToInt32((Byte)a);
                if (type == typeof(Double)) return ((INumberConverter<Double>)this).ToInt32((Double)a);
                if (type == typeof(Single)) return ((INumberConverter<Single>)this).ToInt32((Single)a);
                if (type == typeof(Decimal)) return ((INumberConverter<Decimal>)this).ToInt32((Decimal)a);
				if (type == typeof(DateTime)) return ((INumberConverter<DateTime>)this).ToInt32((DateTime)a);	// NumberConverter.DateTime.cs DateTime -> Int32 
				if (type == typeof(TimeSpan)) return ((INumberConverter<TimeSpan>)this).ToInt32((TimeSpan)a);	// NumberConverter.TimeSpan.cs TimeSpan -> Int32 
				if (type == typeof(Boolean)) return ((INumberConverter<Boolean>)this).ToInt32((Boolean)a);	// NumberConverter.Boolean.cs Boolean -> Int32 
				return Convert.ToInt32(a);
			}

			public Int32 ToInt32(Int32 a)  => Convert.ToInt32(a);
			public Int32 ToInt32(Int32? a) => a.HasValue ? ToInt32(a.Value) : (Int32)0;
			public Int32 ToInt32(Int64 a)  => Convert.ToInt32(a);
			public Int32 ToInt32(Int64? a) => a.HasValue ? ToInt32(a.Value) : (Int32)0;
			public Int32 ToInt32(Int16 a)  => Convert.ToInt32(a);
			public Int32 ToInt32(Int16? a) => a.HasValue ? ToInt32(a.Value) : (Int32)0;
			public Int32 ToInt32(Char a)  => Convert.ToInt32(a);
			public Int32 ToInt32(Char? a) => a.HasValue ? ToInt32(a.Value) : (Int32)0;
			public Int32 ToInt32(UInt32 a)  => Convert.ToInt32(a);
			public Int32 ToInt32(UInt32? a) => a.HasValue ? ToInt32(a.Value) : (Int32)0;
			public Int32 ToInt32(UInt64 a)  => Convert.ToInt32(a);
			public Int32 ToInt32(UInt64? a) => a.HasValue ? ToInt32(a.Value) : (Int32)0;
			public Int32 ToInt32(UInt16 a)  => Convert.ToInt32(a);
			public Int32 ToInt32(UInt16? a) => a.HasValue ? ToInt32(a.Value) : (Int32)0;
			public Int32 ToInt32(Byte a)  => Convert.ToInt32(a);
			public Int32 ToInt32(Byte? a) => a.HasValue ? ToInt32(a.Value) : (Int32)0;
			public Int32 ToInt32(Double a)  => Convert.ToInt32(a);
			public Int32 ToInt32(Double? a) => a.HasValue ? ToInt32(a.Value) : (Int32)0;
			public Int32 ToInt32(Single a)  => Convert.ToInt32(a);
			public Int32 ToInt32(Single? a) => a.HasValue ? ToInt32(a.Value) : (Int32)0;
			public Int32 ToInt32(Decimal a)  => Convert.ToInt32(a);
			public Int32 ToInt32(Decimal? a) => a.HasValue ? ToInt32(a.Value) : (Int32)0;

#endregion Int32 		// Int32 

#region Int64 		// Int64 
			public Int64 ToInt64(object a) 
			{
			    if (a == null) return (Int64) 0;
				Type type = a.GetType();
				if(a is IValue)
				{
					type = ((IValue)a).Type;
					a = ((IValue)a).ValueAsObject();
				}

                if (type == typeof(Int32)) return ((INumberConverter<Int32>)this).ToInt64((Int32)a);
                if (type == typeof(Int64)) return ((INumberConverter<Int64>)this).ToInt64((Int64)a);
                if (type == typeof(Int16)) return ((INumberConverter<Int16>)this).ToInt64((Int16)a);
                if (type == typeof(Char)) return ((INumberConverter<Char>)this).ToInt64((Char)a);
                if (type == typeof(UInt32)) return ((INumberConverter<UInt32>)this).ToInt64((UInt32)a);
                if (type == typeof(UInt64)) return ((INumberConverter<UInt64>)this).ToInt64((UInt64)a);
                if (type == typeof(UInt16)) return ((INumberConverter<UInt16>)this).ToInt64((UInt16)a);
                if (type == typeof(Byte)) return ((INumberConverter<Byte>)this).ToInt64((Byte)a);
                if (type == typeof(Double)) return ((INumberConverter<Double>)this).ToInt64((Double)a);
                if (type == typeof(Single)) return ((INumberConverter<Single>)this).ToInt64((Single)a);
                if (type == typeof(Decimal)) return ((INumberConverter<Decimal>)this).ToInt64((Decimal)a);
				if (type == typeof(DateTime)) return ((INumberConverter<DateTime>)this).ToInt64((DateTime)a);	// NumberConverter.DateTime.cs DateTime -> Int64 
				if (type == typeof(TimeSpan)) return ((INumberConverter<TimeSpan>)this).ToInt64((TimeSpan)a);	// NumberConverter.TimeSpan.cs TimeSpan -> Int64 
				if (type == typeof(Boolean)) return ((INumberConverter<Boolean>)this).ToInt64((Boolean)a);	// NumberConverter.Boolean.cs Boolean -> Int64 
				return Convert.ToInt64(a);
			}

			public Int64 ToInt64(Int32 a)  => Convert.ToInt64(a);
			public Int64 ToInt64(Int32? a) => a.HasValue ? ToInt64(a.Value) : (Int64)0;
			public Int64 ToInt64(Int64 a)  => Convert.ToInt64(a);
			public Int64 ToInt64(Int64? a) => a.HasValue ? ToInt64(a.Value) : (Int64)0;
			public Int64 ToInt64(Int16 a)  => Convert.ToInt64(a);
			public Int64 ToInt64(Int16? a) => a.HasValue ? ToInt64(a.Value) : (Int64)0;
			public Int64 ToInt64(Char a)  => Convert.ToInt64(a);
			public Int64 ToInt64(Char? a) => a.HasValue ? ToInt64(a.Value) : (Int64)0;
			public Int64 ToInt64(UInt32 a)  => Convert.ToInt64(a);
			public Int64 ToInt64(UInt32? a) => a.HasValue ? ToInt64(a.Value) : (Int64)0;
			public Int64 ToInt64(UInt64 a)  => Convert.ToInt64(a);
			public Int64 ToInt64(UInt64? a) => a.HasValue ? ToInt64(a.Value) : (Int64)0;
			public Int64 ToInt64(UInt16 a)  => Convert.ToInt64(a);
			public Int64 ToInt64(UInt16? a) => a.HasValue ? ToInt64(a.Value) : (Int64)0;
			public Int64 ToInt64(Byte a)  => Convert.ToInt64(a);
			public Int64 ToInt64(Byte? a) => a.HasValue ? ToInt64(a.Value) : (Int64)0;
			public Int64 ToInt64(Double a)  => Convert.ToInt64(a);
			public Int64 ToInt64(Double? a) => a.HasValue ? ToInt64(a.Value) : (Int64)0;
			public Int64 ToInt64(Single a)  => Convert.ToInt64(a);
			public Int64 ToInt64(Single? a) => a.HasValue ? ToInt64(a.Value) : (Int64)0;
			public Int64 ToInt64(Decimal a)  => Convert.ToInt64(a);
			public Int64 ToInt64(Decimal? a) => a.HasValue ? ToInt64(a.Value) : (Int64)0;

#endregion Int64 		// Int64 

#region Int16 		// Int16 
			public Int16 ToInt16(object a) 
			{
			    if (a == null) return (Int16) 0;
				Type type = a.GetType();
				if(a is IValue)
				{
					type = ((IValue)a).Type;
					a = ((IValue)a).ValueAsObject();
				}

                if (type == typeof(Int32)) return ((INumberConverter<Int32>)this).ToInt16((Int32)a);
                if (type == typeof(Int64)) return ((INumberConverter<Int64>)this).ToInt16((Int64)a);
                if (type == typeof(Int16)) return ((INumberConverter<Int16>)this).ToInt16((Int16)a);
                if (type == typeof(Char)) return ((INumberConverter<Char>)this).ToInt16((Char)a);
                if (type == typeof(UInt32)) return ((INumberConverter<UInt32>)this).ToInt16((UInt32)a);
                if (type == typeof(UInt64)) return ((INumberConverter<UInt64>)this).ToInt16((UInt64)a);
                if (type == typeof(UInt16)) return ((INumberConverter<UInt16>)this).ToInt16((UInt16)a);
                if (type == typeof(Byte)) return ((INumberConverter<Byte>)this).ToInt16((Byte)a);
                if (type == typeof(Double)) return ((INumberConverter<Double>)this).ToInt16((Double)a);
                if (type == typeof(Single)) return ((INumberConverter<Single>)this).ToInt16((Single)a);
                if (type == typeof(Decimal)) return ((INumberConverter<Decimal>)this).ToInt16((Decimal)a);
				if (type == typeof(DateTime)) return ((INumberConverter<DateTime>)this).ToInt16((DateTime)a);	// NumberConverter.DateTime.cs DateTime -> Int16 
				if (type == typeof(TimeSpan)) return ((INumberConverter<TimeSpan>)this).ToInt16((TimeSpan)a);	// NumberConverter.TimeSpan.cs TimeSpan -> Int16 
				if (type == typeof(Boolean)) return ((INumberConverter<Boolean>)this).ToInt16((Boolean)a);	// NumberConverter.Boolean.cs Boolean -> Int16 
				return Convert.ToInt16(a);
			}

			public Int16 ToInt16(Int32 a)  => Convert.ToInt16(a);
			public Int16 ToInt16(Int32? a) => a.HasValue ? ToInt16(a.Value) : (Int16)0;
			public Int16 ToInt16(Int64 a)  => Convert.ToInt16(a);
			public Int16 ToInt16(Int64? a) => a.HasValue ? ToInt16(a.Value) : (Int16)0;
			public Int16 ToInt16(Int16 a)  => Convert.ToInt16(a);
			public Int16 ToInt16(Int16? a) => a.HasValue ? ToInt16(a.Value) : (Int16)0;
			public Int16 ToInt16(Char a)  => Convert.ToInt16(a);
			public Int16 ToInt16(Char? a) => a.HasValue ? ToInt16(a.Value) : (Int16)0;
			public Int16 ToInt16(UInt32 a)  => Convert.ToInt16(a);
			public Int16 ToInt16(UInt32? a) => a.HasValue ? ToInt16(a.Value) : (Int16)0;
			public Int16 ToInt16(UInt64 a)  => Convert.ToInt16(a);
			public Int16 ToInt16(UInt64? a) => a.HasValue ? ToInt16(a.Value) : (Int16)0;
			public Int16 ToInt16(UInt16 a)  => Convert.ToInt16(a);
			public Int16 ToInt16(UInt16? a) => a.HasValue ? ToInt16(a.Value) : (Int16)0;
			public Int16 ToInt16(Byte a)  => Convert.ToInt16(a);
			public Int16 ToInt16(Byte? a) => a.HasValue ? ToInt16(a.Value) : (Int16)0;
			public Int16 ToInt16(Double a)  => Convert.ToInt16(a);
			public Int16 ToInt16(Double? a) => a.HasValue ? ToInt16(a.Value) : (Int16)0;
			public Int16 ToInt16(Single a)  => Convert.ToInt16(a);
			public Int16 ToInt16(Single? a) => a.HasValue ? ToInt16(a.Value) : (Int16)0;
			public Int16 ToInt16(Decimal a)  => Convert.ToInt16(a);
			public Int16 ToInt16(Decimal? a) => a.HasValue ? ToInt16(a.Value) : (Int16)0;

#endregion Int16 		// Int16 

#region Char 		// Char 
			public Char ToChar(object a) 
			{
			    if (a == null) return (Char) 0;
				Type type = a.GetType();
				if(a is IValue)
				{
					type = ((IValue)a).Type;
					a = ((IValue)a).ValueAsObject();
				}

                if (type == typeof(Int32)) return ((INumberConverter<Int32>)this).ToChar((Int32)a);
                if (type == typeof(Int64)) return ((INumberConverter<Int64>)this).ToChar((Int64)a);
                if (type == typeof(Int16)) return ((INumberConverter<Int16>)this).ToChar((Int16)a);
                if (type == typeof(Char)) return ((INumberConverter<Char>)this).ToChar((Char)a);
                if (type == typeof(UInt32)) return ((INumberConverter<UInt32>)this).ToChar((UInt32)a);
                if (type == typeof(UInt64)) return ((INumberConverter<UInt64>)this).ToChar((UInt64)a);
                if (type == typeof(UInt16)) return ((INumberConverter<UInt16>)this).ToChar((UInt16)a);
                if (type == typeof(Byte)) return ((INumberConverter<Byte>)this).ToChar((Byte)a);
                if (type == typeof(Double)) return ((INumberConverter<Double>)this).ToChar((Double)a);
                if (type == typeof(Single)) return ((INumberConverter<Single>)this).ToChar((Single)a);
                if (type == typeof(Decimal)) return ((INumberConverter<Decimal>)this).ToChar((Decimal)a);
				if (type == typeof(DateTime)) return ((INumberConverter<DateTime>)this).ToChar((DateTime)a);	// NumberConverter.DateTime.cs DateTime -> Char 
				if (type == typeof(TimeSpan)) return ((INumberConverter<TimeSpan>)this).ToChar((TimeSpan)a);	// NumberConverter.TimeSpan.cs TimeSpan -> Char 
				if (type == typeof(Boolean)) return ((INumberConverter<Boolean>)this).ToChar((Boolean)a);	// NumberConverter.Boolean.cs Boolean -> Char 
				return Convert.ToChar(Convert.ToInt32(a));
			}

			public Char ToChar(Int32 a)  => Convert.ToChar(a);
			public Char ToChar(Int32? a) => a.HasValue ? ToChar(a.Value) : (Char)0;
			public Char ToChar(Int64 a)  => Convert.ToChar(a);
			public Char ToChar(Int64? a) => a.HasValue ? ToChar(a.Value) : (Char)0;
			public Char ToChar(Int16 a)  => Convert.ToChar(a);
			public Char ToChar(Int16? a) => a.HasValue ? ToChar(a.Value) : (Char)0;
			public Char ToChar(Char a)  => Convert.ToChar(a);
			public Char ToChar(Char? a) => a.HasValue ? ToChar(a.Value) : (Char)0;
			public Char ToChar(UInt32 a)  => Convert.ToChar(a);
			public Char ToChar(UInt32? a) => a.HasValue ? ToChar(a.Value) : (Char)0;
			public Char ToChar(UInt64 a)  => Convert.ToChar(a);
			public Char ToChar(UInt64? a) => a.HasValue ? ToChar(a.Value) : (Char)0;
			public Char ToChar(UInt16 a)  => Convert.ToChar(a);
			public Char ToChar(UInt16? a) => a.HasValue ? ToChar(a.Value) : (Char)0;
			public Char ToChar(Byte a)  => Convert.ToChar(a);
			public Char ToChar(Byte? a) => a.HasValue ? ToChar(a.Value) : (Char)0;
			public Char ToChar(Double a) => Convert.ToChar(Convert.ToInt32(a));	// char  -> Double throws exception
			public Char ToChar(Double? a) => a.HasValue ? ToChar(a.Value) : (Char)0;
			public Char ToChar(Single a) => Convert.ToChar(Convert.ToInt32(a));	// char  -> Single throws exception
			public Char ToChar(Single? a) => a.HasValue ? ToChar(a.Value) : (Char)0;
			public Char ToChar(Decimal a) => Convert.ToChar(Convert.ToInt32(a));	// char  -> Decimal throws exception
			public Char ToChar(Decimal? a) => a.HasValue ? ToChar(a.Value) : (Char)0;

#endregion Char 		// Char 

#region UInt32 		// UInt32 
			public UInt32 ToUInt32(object a) 
			{
			    if (a == null) return (UInt32) 0;
				Type type = a.GetType();
				if(a is IValue)
				{
					type = ((IValue)a).Type;
					a = ((IValue)a).ValueAsObject();
				}

                if (type == typeof(Int32)) return ((INumberConverter<Int32>)this).ToUInt32((Int32)a);
                if (type == typeof(Int64)) return ((INumberConverter<Int64>)this).ToUInt32((Int64)a);
                if (type == typeof(Int16)) return ((INumberConverter<Int16>)this).ToUInt32((Int16)a);
                if (type == typeof(Char)) return ((INumberConverter<Char>)this).ToUInt32((Char)a);
                if (type == typeof(UInt32)) return ((INumberConverter<UInt32>)this).ToUInt32((UInt32)a);
                if (type == typeof(UInt64)) return ((INumberConverter<UInt64>)this).ToUInt32((UInt64)a);
                if (type == typeof(UInt16)) return ((INumberConverter<UInt16>)this).ToUInt32((UInt16)a);
                if (type == typeof(Byte)) return ((INumberConverter<Byte>)this).ToUInt32((Byte)a);
                if (type == typeof(Double)) return ((INumberConverter<Double>)this).ToUInt32((Double)a);
                if (type == typeof(Single)) return ((INumberConverter<Single>)this).ToUInt32((Single)a);
                if (type == typeof(Decimal)) return ((INumberConverter<Decimal>)this).ToUInt32((Decimal)a);
				if (type == typeof(DateTime)) return ((INumberConverter<DateTime>)this).ToUInt32((DateTime)a);	// NumberConverter.DateTime.cs DateTime -> UInt32 
				if (type == typeof(TimeSpan)) return ((INumberConverter<TimeSpan>)this).ToUInt32((TimeSpan)a);	// NumberConverter.TimeSpan.cs TimeSpan -> UInt32 
				if (type == typeof(Boolean)) return ((INumberConverter<Boolean>)this).ToUInt32((Boolean)a);	// NumberConverter.Boolean.cs Boolean -> UInt32 
				return Convert.ToUInt32(a);
			}

			public UInt32 ToUInt32(Int32 a)  => Convert.ToUInt32(a);
			public UInt32 ToUInt32(Int32? a) => a.HasValue ? ToUInt32(a.Value) : (UInt32)0;
			public UInt32 ToUInt32(Int64 a)  => Convert.ToUInt32(a);
			public UInt32 ToUInt32(Int64? a) => a.HasValue ? ToUInt32(a.Value) : (UInt32)0;
			public UInt32 ToUInt32(Int16 a)  => Convert.ToUInt32(a);
			public UInt32 ToUInt32(Int16? a) => a.HasValue ? ToUInt32(a.Value) : (UInt32)0;
			public UInt32 ToUInt32(Char a)  => Convert.ToUInt32(a);
			public UInt32 ToUInt32(Char? a) => a.HasValue ? ToUInt32(a.Value) : (UInt32)0;
			public UInt32 ToUInt32(UInt32 a)  => Convert.ToUInt32(a);
			public UInt32 ToUInt32(UInt32? a) => a.HasValue ? ToUInt32(a.Value) : (UInt32)0;
			public UInt32 ToUInt32(UInt64 a)  => Convert.ToUInt32(a);
			public UInt32 ToUInt32(UInt64? a) => a.HasValue ? ToUInt32(a.Value) : (UInt32)0;
			public UInt32 ToUInt32(UInt16 a)  => Convert.ToUInt32(a);
			public UInt32 ToUInt32(UInt16? a) => a.HasValue ? ToUInt32(a.Value) : (UInt32)0;
			public UInt32 ToUInt32(Byte a)  => Convert.ToUInt32(a);
			public UInt32 ToUInt32(Byte? a) => a.HasValue ? ToUInt32(a.Value) : (UInt32)0;
			public UInt32 ToUInt32(Double a)  => Convert.ToUInt32(a);
			public UInt32 ToUInt32(Double? a) => a.HasValue ? ToUInt32(a.Value) : (UInt32)0;
			public UInt32 ToUInt32(Single a)  => Convert.ToUInt32(a);
			public UInt32 ToUInt32(Single? a) => a.HasValue ? ToUInt32(a.Value) : (UInt32)0;
			public UInt32 ToUInt32(Decimal a)  => Convert.ToUInt32(a);
			public UInt32 ToUInt32(Decimal? a) => a.HasValue ? ToUInt32(a.Value) : (UInt32)0;

#endregion UInt32 		// UInt32 

#region UInt64 		// UInt64 
			public UInt64 ToUInt64(object a) 
			{
			    if (a == null) return (UInt64) 0;
				Type type = a.GetType();
				if(a is IValue)
				{
					type = ((IValue)a).Type;
					a = ((IValue)a).ValueAsObject();
				}

                if (type == typeof(Int32)) return ((INumberConverter<Int32>)this).ToUInt64((Int32)a);
                if (type == typeof(Int64)) return ((INumberConverter<Int64>)this).ToUInt64((Int64)a);
                if (type == typeof(Int16)) return ((INumberConverter<Int16>)this).ToUInt64((Int16)a);
                if (type == typeof(Char)) return ((INumberConverter<Char>)this).ToUInt64((Char)a);
                if (type == typeof(UInt32)) return ((INumberConverter<UInt32>)this).ToUInt64((UInt32)a);
                if (type == typeof(UInt64)) return ((INumberConverter<UInt64>)this).ToUInt64((UInt64)a);
                if (type == typeof(UInt16)) return ((INumberConverter<UInt16>)this).ToUInt64((UInt16)a);
                if (type == typeof(Byte)) return ((INumberConverter<Byte>)this).ToUInt64((Byte)a);
                if (type == typeof(Double)) return ((INumberConverter<Double>)this).ToUInt64((Double)a);
                if (type == typeof(Single)) return ((INumberConverter<Single>)this).ToUInt64((Single)a);
                if (type == typeof(Decimal)) return ((INumberConverter<Decimal>)this).ToUInt64((Decimal)a);
				if (type == typeof(DateTime)) return ((INumberConverter<DateTime>)this).ToUInt64((DateTime)a);	// NumberConverter.DateTime.cs DateTime -> UInt64 
				if (type == typeof(TimeSpan)) return ((INumberConverter<TimeSpan>)this).ToUInt64((TimeSpan)a);	// NumberConverter.TimeSpan.cs TimeSpan -> UInt64 
				if (type == typeof(Boolean)) return ((INumberConverter<Boolean>)this).ToUInt64((Boolean)a);	// NumberConverter.Boolean.cs Boolean -> UInt64 
				return Convert.ToUInt64(a);
			}

			public UInt64 ToUInt64(Int32 a)  => Convert.ToUInt64(a);
			public UInt64 ToUInt64(Int32? a) => a.HasValue ? ToUInt64(a.Value) : (UInt64)0;
			public UInt64 ToUInt64(Int64 a)  => Convert.ToUInt64(a);
			public UInt64 ToUInt64(Int64? a) => a.HasValue ? ToUInt64(a.Value) : (UInt64)0;
			public UInt64 ToUInt64(Int16 a)  => Convert.ToUInt64(a);
			public UInt64 ToUInt64(Int16? a) => a.HasValue ? ToUInt64(a.Value) : (UInt64)0;
			public UInt64 ToUInt64(Char a)  => Convert.ToUInt64(a);
			public UInt64 ToUInt64(Char? a) => a.HasValue ? ToUInt64(a.Value) : (UInt64)0;
			public UInt64 ToUInt64(UInt32 a)  => Convert.ToUInt64(a);
			public UInt64 ToUInt64(UInt32? a) => a.HasValue ? ToUInt64(a.Value) : (UInt64)0;
			public UInt64 ToUInt64(UInt64 a)  => Convert.ToUInt64(a);
			public UInt64 ToUInt64(UInt64? a) => a.HasValue ? ToUInt64(a.Value) : (UInt64)0;
			public UInt64 ToUInt64(UInt16 a)  => Convert.ToUInt64(a);
			public UInt64 ToUInt64(UInt16? a) => a.HasValue ? ToUInt64(a.Value) : (UInt64)0;
			public UInt64 ToUInt64(Byte a)  => Convert.ToUInt64(a);
			public UInt64 ToUInt64(Byte? a) => a.HasValue ? ToUInt64(a.Value) : (UInt64)0;
			public UInt64 ToUInt64(Double a)  => Convert.ToUInt64(a);
			public UInt64 ToUInt64(Double? a) => a.HasValue ? ToUInt64(a.Value) : (UInt64)0;
			public UInt64 ToUInt64(Single a)  => Convert.ToUInt64(a);
			public UInt64 ToUInt64(Single? a) => a.HasValue ? ToUInt64(a.Value) : (UInt64)0;
			public UInt64 ToUInt64(Decimal a)  => Convert.ToUInt64(a);
			public UInt64 ToUInt64(Decimal? a) => a.HasValue ? ToUInt64(a.Value) : (UInt64)0;

#endregion UInt64 		// UInt64 

#region UInt16 		// UInt16 
			public UInt16 ToUInt16(object a) 
			{
			    if (a == null) return (UInt16) 0;
				Type type = a.GetType();
				if(a is IValue)
				{
					type = ((IValue)a).Type;
					a = ((IValue)a).ValueAsObject();
				}

                if (type == typeof(Int32)) return ((INumberConverter<Int32>)this).ToUInt16((Int32)a);
                if (type == typeof(Int64)) return ((INumberConverter<Int64>)this).ToUInt16((Int64)a);
                if (type == typeof(Int16)) return ((INumberConverter<Int16>)this).ToUInt16((Int16)a);
                if (type == typeof(Char)) return ((INumberConverter<Char>)this).ToUInt16((Char)a);
                if (type == typeof(UInt32)) return ((INumberConverter<UInt32>)this).ToUInt16((UInt32)a);
                if (type == typeof(UInt64)) return ((INumberConverter<UInt64>)this).ToUInt16((UInt64)a);
                if (type == typeof(UInt16)) return ((INumberConverter<UInt16>)this).ToUInt16((UInt16)a);
                if (type == typeof(Byte)) return ((INumberConverter<Byte>)this).ToUInt16((Byte)a);
                if (type == typeof(Double)) return ((INumberConverter<Double>)this).ToUInt16((Double)a);
                if (type == typeof(Single)) return ((INumberConverter<Single>)this).ToUInt16((Single)a);
                if (type == typeof(Decimal)) return ((INumberConverter<Decimal>)this).ToUInt16((Decimal)a);
				if (type == typeof(DateTime)) return ((INumberConverter<DateTime>)this).ToUInt16((DateTime)a);	// NumberConverter.DateTime.cs DateTime -> UInt16 
				if (type == typeof(TimeSpan)) return ((INumberConverter<TimeSpan>)this).ToUInt16((TimeSpan)a);	// NumberConverter.TimeSpan.cs TimeSpan -> UInt16 
				if (type == typeof(Boolean)) return ((INumberConverter<Boolean>)this).ToUInt16((Boolean)a);	// NumberConverter.Boolean.cs Boolean -> UInt16 
				return Convert.ToUInt16(a);
			}

			public UInt16 ToUInt16(Int32 a)  => Convert.ToUInt16(a);
			public UInt16 ToUInt16(Int32? a) => a.HasValue ? ToUInt16(a.Value) : (UInt16)0;
			public UInt16 ToUInt16(Int64 a)  => Convert.ToUInt16(a);
			public UInt16 ToUInt16(Int64? a) => a.HasValue ? ToUInt16(a.Value) : (UInt16)0;
			public UInt16 ToUInt16(Int16 a)  => Convert.ToUInt16(a);
			public UInt16 ToUInt16(Int16? a) => a.HasValue ? ToUInt16(a.Value) : (UInt16)0;
			public UInt16 ToUInt16(Char a)  => Convert.ToUInt16(a);
			public UInt16 ToUInt16(Char? a) => a.HasValue ? ToUInt16(a.Value) : (UInt16)0;
			public UInt16 ToUInt16(UInt32 a)  => Convert.ToUInt16(a);
			public UInt16 ToUInt16(UInt32? a) => a.HasValue ? ToUInt16(a.Value) : (UInt16)0;
			public UInt16 ToUInt16(UInt64 a)  => Convert.ToUInt16(a);
			public UInt16 ToUInt16(UInt64? a) => a.HasValue ? ToUInt16(a.Value) : (UInt16)0;
			public UInt16 ToUInt16(UInt16 a)  => Convert.ToUInt16(a);
			public UInt16 ToUInt16(UInt16? a) => a.HasValue ? ToUInt16(a.Value) : (UInt16)0;
			public UInt16 ToUInt16(Byte a)  => Convert.ToUInt16(a);
			public UInt16 ToUInt16(Byte? a) => a.HasValue ? ToUInt16(a.Value) : (UInt16)0;
			public UInt16 ToUInt16(Double a)  => Convert.ToUInt16(a);
			public UInt16 ToUInt16(Double? a) => a.HasValue ? ToUInt16(a.Value) : (UInt16)0;
			public UInt16 ToUInt16(Single a)  => Convert.ToUInt16(a);
			public UInt16 ToUInt16(Single? a) => a.HasValue ? ToUInt16(a.Value) : (UInt16)0;
			public UInt16 ToUInt16(Decimal a)  => Convert.ToUInt16(a);
			public UInt16 ToUInt16(Decimal? a) => a.HasValue ? ToUInt16(a.Value) : (UInt16)0;

#endregion UInt16 		// UInt16 

#region Byte 		// Byte 
			public Byte ToByte(object a) 
			{
			    if (a == null) return (Byte) 0;
				Type type = a.GetType();
				if(a is IValue)
				{
					type = ((IValue)a).Type;
					a = ((IValue)a).ValueAsObject();
				}

                if (type == typeof(Int32)) return ((INumberConverter<Int32>)this).ToByte((Int32)a);
                if (type == typeof(Int64)) return ((INumberConverter<Int64>)this).ToByte((Int64)a);
                if (type == typeof(Int16)) return ((INumberConverter<Int16>)this).ToByte((Int16)a);
                if (type == typeof(Char)) return ((INumberConverter<Char>)this).ToByte((Char)a);
                if (type == typeof(UInt32)) return ((INumberConverter<UInt32>)this).ToByte((UInt32)a);
                if (type == typeof(UInt64)) return ((INumberConverter<UInt64>)this).ToByte((UInt64)a);
                if (type == typeof(UInt16)) return ((INumberConverter<UInt16>)this).ToByte((UInt16)a);
                if (type == typeof(Byte)) return ((INumberConverter<Byte>)this).ToByte((Byte)a);
                if (type == typeof(Double)) return ((INumberConverter<Double>)this).ToByte((Double)a);
                if (type == typeof(Single)) return ((INumberConverter<Single>)this).ToByte((Single)a);
                if (type == typeof(Decimal)) return ((INumberConverter<Decimal>)this).ToByte((Decimal)a);
				if (type == typeof(DateTime)) return ((INumberConverter<DateTime>)this).ToByte((DateTime)a);	// NumberConverter.DateTime.cs DateTime -> Byte 
				if (type == typeof(TimeSpan)) return ((INumberConverter<TimeSpan>)this).ToByte((TimeSpan)a);	// NumberConverter.TimeSpan.cs TimeSpan -> Byte 
				if (type == typeof(Boolean)) return ((INumberConverter<Boolean>)this).ToByte((Boolean)a);	// NumberConverter.Boolean.cs Boolean -> Byte 
				return Convert.ToByte(a);
			}

			public Byte ToByte(Int32 a)  => Convert.ToByte(a);
			public Byte ToByte(Int32? a) => a.HasValue ? ToByte(a.Value) : (Byte)0;
			public Byte ToByte(Int64 a)  => Convert.ToByte(a);
			public Byte ToByte(Int64? a) => a.HasValue ? ToByte(a.Value) : (Byte)0;
			public Byte ToByte(Int16 a)  => Convert.ToByte(a);
			public Byte ToByte(Int16? a) => a.HasValue ? ToByte(a.Value) : (Byte)0;
			public Byte ToByte(Char a)  => Convert.ToByte(a);
			public Byte ToByte(Char? a) => a.HasValue ? ToByte(a.Value) : (Byte)0;
			public Byte ToByte(UInt32 a)  => Convert.ToByte(a);
			public Byte ToByte(UInt32? a) => a.HasValue ? ToByte(a.Value) : (Byte)0;
			public Byte ToByte(UInt64 a)  => Convert.ToByte(a);
			public Byte ToByte(UInt64? a) => a.HasValue ? ToByte(a.Value) : (Byte)0;
			public Byte ToByte(UInt16 a)  => Convert.ToByte(a);
			public Byte ToByte(UInt16? a) => a.HasValue ? ToByte(a.Value) : (Byte)0;
			public Byte ToByte(Byte a)  => Convert.ToByte(a);
			public Byte ToByte(Byte? a) => a.HasValue ? ToByte(a.Value) : (Byte)0;
			public Byte ToByte(Double a)  => Convert.ToByte(a);
			public Byte ToByte(Double? a) => a.HasValue ? ToByte(a.Value) : (Byte)0;
			public Byte ToByte(Single a)  => Convert.ToByte(a);
			public Byte ToByte(Single? a) => a.HasValue ? ToByte(a.Value) : (Byte)0;
			public Byte ToByte(Decimal a)  => Convert.ToByte(a);
			public Byte ToByte(Decimal? a) => a.HasValue ? ToByte(a.Value) : (Byte)0;

#endregion Byte 		// Byte 

#region Double 		// Double 
			public Double ToDouble(object a) 
			{
			    if (a == null) return (Double) 0;
				Type type = a.GetType();
				if(a is IValue)
				{
					type = ((IValue)a).Type;
					a = ((IValue)a).ValueAsObject();
				}

                if (type == typeof(Int32)) return ((INumberConverter<Int32>)this).ToDouble((Int32)a);
                if (type == typeof(Int64)) return ((INumberConverter<Int64>)this).ToDouble((Int64)a);
                if (type == typeof(Int16)) return ((INumberConverter<Int16>)this).ToDouble((Int16)a);
                if (type == typeof(Char)) return ((INumberConverter<Char>)this).ToDouble((Char)a);
                if (type == typeof(UInt32)) return ((INumberConverter<UInt32>)this).ToDouble((UInt32)a);
                if (type == typeof(UInt64)) return ((INumberConverter<UInt64>)this).ToDouble((UInt64)a);
                if (type == typeof(UInt16)) return ((INumberConverter<UInt16>)this).ToDouble((UInt16)a);
                if (type == typeof(Byte)) return ((INumberConverter<Byte>)this).ToDouble((Byte)a);
                if (type == typeof(Double)) return ((INumberConverter<Double>)this).ToDouble((Double)a);
                if (type == typeof(Single)) return ((INumberConverter<Single>)this).ToDouble((Single)a);
                if (type == typeof(Decimal)) return ((INumberConverter<Decimal>)this).ToDouble((Decimal)a);
				if (type == typeof(DateTime)) return ((INumberConverter<DateTime>)this).ToDouble((DateTime)a);	// NumberConverter.DateTime.cs DateTime -> Double 
				if (type == typeof(TimeSpan)) return ((INumberConverter<TimeSpan>)this).ToDouble((TimeSpan)a);	// NumberConverter.TimeSpan.cs TimeSpan -> Double 
				if (type == typeof(Boolean)) return ((INumberConverter<Boolean>)this).ToDouble((Boolean)a);	// NumberConverter.Boolean.cs Boolean -> Double 
				return Convert.ToDouble(a);
			}

			public Double ToDouble(Int32 a)  => Convert.ToDouble(a);
			public Double ToDouble(Int32? a) => a.HasValue ? ToDouble(a.Value) : (Double)0;
			public Double ToDouble(Int64 a)  => Convert.ToDouble(a);
			public Double ToDouble(Int64? a) => a.HasValue ? ToDouble(a.Value) : (Double)0;
			public Double ToDouble(Int16 a)  => Convert.ToDouble(a);
			public Double ToDouble(Int16? a) => a.HasValue ? ToDouble(a.Value) : (Double)0;
			public Double ToDouble(Char a) => Convert.ToDouble(Convert.ToInt32(a));	// double -> Char throws exception
			public Double ToDouble(Char? a) => a.HasValue ? ToDouble(a.Value) : (Double)0;
			public Double ToDouble(UInt32 a)  => Convert.ToDouble(a);
			public Double ToDouble(UInt32? a) => a.HasValue ? ToDouble(a.Value) : (Double)0;
			public Double ToDouble(UInt64 a)  => Convert.ToDouble(a);
			public Double ToDouble(UInt64? a) => a.HasValue ? ToDouble(a.Value) : (Double)0;
			public Double ToDouble(UInt16 a)  => Convert.ToDouble(a);
			public Double ToDouble(UInt16? a) => a.HasValue ? ToDouble(a.Value) : (Double)0;
			public Double ToDouble(Byte a)  => Convert.ToDouble(a);
			public Double ToDouble(Byte? a) => a.HasValue ? ToDouble(a.Value) : (Double)0;
			public Double ToDouble(Double a)  => Convert.ToDouble(a);
			public Double ToDouble(Double? a) => a.HasValue ? ToDouble(a.Value) : (Double)0;
			public Double ToDouble(Single a)  => Convert.ToDouble(a);
			public Double ToDouble(Single? a) => a.HasValue ? ToDouble(a.Value) : (Double)0;
			public Double ToDouble(Decimal a)  => Convert.ToDouble(a);
			public Double ToDouble(Decimal? a) => a.HasValue ? ToDouble(a.Value) : (Double)0;

#endregion Double 		// Double 

#region Single 		// Single 
			public Single ToSingle(object a) 
			{
			    if (a == null) return (Single) 0;
				Type type = a.GetType();
				if(a is IValue)
				{
					type = ((IValue)a).Type;
					a = ((IValue)a).ValueAsObject();
				}

                if (type == typeof(Int32)) return ((INumberConverter<Int32>)this).ToSingle((Int32)a);
                if (type == typeof(Int64)) return ((INumberConverter<Int64>)this).ToSingle((Int64)a);
                if (type == typeof(Int16)) return ((INumberConverter<Int16>)this).ToSingle((Int16)a);
                if (type == typeof(Char)) return ((INumberConverter<Char>)this).ToSingle((Char)a);
                if (type == typeof(UInt32)) return ((INumberConverter<UInt32>)this).ToSingle((UInt32)a);
                if (type == typeof(UInt64)) return ((INumberConverter<UInt64>)this).ToSingle((UInt64)a);
                if (type == typeof(UInt16)) return ((INumberConverter<UInt16>)this).ToSingle((UInt16)a);
                if (type == typeof(Byte)) return ((INumberConverter<Byte>)this).ToSingle((Byte)a);
                if (type == typeof(Double)) return ((INumberConverter<Double>)this).ToSingle((Double)a);
                if (type == typeof(Single)) return ((INumberConverter<Single>)this).ToSingle((Single)a);
                if (type == typeof(Decimal)) return ((INumberConverter<Decimal>)this).ToSingle((Decimal)a);
				if (type == typeof(DateTime)) return ((INumberConverter<DateTime>)this).ToSingle((DateTime)a);	// NumberConverter.DateTime.cs DateTime -> Single 
				if (type == typeof(TimeSpan)) return ((INumberConverter<TimeSpan>)this).ToSingle((TimeSpan)a);	// NumberConverter.TimeSpan.cs TimeSpan -> Single 
				if (type == typeof(Boolean)) return ((INumberConverter<Boolean>)this).ToSingle((Boolean)a);	// NumberConverter.Boolean.cs Boolean -> Single 
				return Convert.ToSingle(a);
			}

			public Single ToSingle(Int32 a)  => Convert.ToSingle(a);
			public Single ToSingle(Int32? a) => a.HasValue ? ToSingle(a.Value) : (Single)0;
			public Single ToSingle(Int64 a)  => Convert.ToSingle(a);
			public Single ToSingle(Int64? a) => a.HasValue ? ToSingle(a.Value) : (Single)0;
			public Single ToSingle(Int16 a)  => Convert.ToSingle(a);
			public Single ToSingle(Int16? a) => a.HasValue ? ToSingle(a.Value) : (Single)0;
			public Single ToSingle(Char a) => Convert.ToSingle(Convert.ToInt32(a));	// double -> Char throws exception
			public Single ToSingle(Char? a) => a.HasValue ? ToSingle(a.Value) : (Single)0;
			public Single ToSingle(UInt32 a)  => Convert.ToSingle(a);
			public Single ToSingle(UInt32? a) => a.HasValue ? ToSingle(a.Value) : (Single)0;
			public Single ToSingle(UInt64 a)  => Convert.ToSingle(a);
			public Single ToSingle(UInt64? a) => a.HasValue ? ToSingle(a.Value) : (Single)0;
			public Single ToSingle(UInt16 a)  => Convert.ToSingle(a);
			public Single ToSingle(UInt16? a) => a.HasValue ? ToSingle(a.Value) : (Single)0;
			public Single ToSingle(Byte a)  => Convert.ToSingle(a);
			public Single ToSingle(Byte? a) => a.HasValue ? ToSingle(a.Value) : (Single)0;
			public Single ToSingle(Double a)  => Convert.ToSingle(a);
			public Single ToSingle(Double? a) => a.HasValue ? ToSingle(a.Value) : (Single)0;
			public Single ToSingle(Single a)  => Convert.ToSingle(a);
			public Single ToSingle(Single? a) => a.HasValue ? ToSingle(a.Value) : (Single)0;
			public Single ToSingle(Decimal a)  => Convert.ToSingle(a);
			public Single ToSingle(Decimal? a) => a.HasValue ? ToSingle(a.Value) : (Single)0;

#endregion Single 		// Single 

#region Decimal 		// Decimal 
			public Decimal ToDecimal(object a) 
			{
			    if (a == null) return (Decimal) 0;
				Type type = a.GetType();
				if(a is IValue)
				{
					type = ((IValue)a).Type;
					a = ((IValue)a).ValueAsObject();
				}

                if (type == typeof(Int32)) return ((INumberConverter<Int32>)this).ToDecimal((Int32)a);
                if (type == typeof(Int64)) return ((INumberConverter<Int64>)this).ToDecimal((Int64)a);
                if (type == typeof(Int16)) return ((INumberConverter<Int16>)this).ToDecimal((Int16)a);
                if (type == typeof(Char)) return ((INumberConverter<Char>)this).ToDecimal((Char)a);
                if (type == typeof(UInt32)) return ((INumberConverter<UInt32>)this).ToDecimal((UInt32)a);
                if (type == typeof(UInt64)) return ((INumberConverter<UInt64>)this).ToDecimal((UInt64)a);
                if (type == typeof(UInt16)) return ((INumberConverter<UInt16>)this).ToDecimal((UInt16)a);
                if (type == typeof(Byte)) return ((INumberConverter<Byte>)this).ToDecimal((Byte)a);
                if (type == typeof(Double)) return ((INumberConverter<Double>)this).ToDecimal((Double)a);
                if (type == typeof(Single)) return ((INumberConverter<Single>)this).ToDecimal((Single)a);
                if (type == typeof(Decimal)) return ((INumberConverter<Decimal>)this).ToDecimal((Decimal)a);
				if (type == typeof(DateTime)) return ((INumberConverter<DateTime>)this).ToDecimal((DateTime)a);	// NumberConverter.DateTime.cs DateTime -> Decimal 
				if (type == typeof(TimeSpan)) return ((INumberConverter<TimeSpan>)this).ToDecimal((TimeSpan)a);	// NumberConverter.TimeSpan.cs TimeSpan -> Decimal 
				if (type == typeof(Boolean)) return ((INumberConverter<Boolean>)this).ToDecimal((Boolean)a);	// NumberConverter.Boolean.cs Boolean -> Decimal 
				return Convert.ToDecimal(a);
			}

			public Decimal ToDecimal(Int32 a)  => Convert.ToDecimal(a);
			public Decimal ToDecimal(Int32? a) => a.HasValue ? ToDecimal(a.Value) : (Decimal)0;
			public Decimal ToDecimal(Int64 a)  => Convert.ToDecimal(a);
			public Decimal ToDecimal(Int64? a) => a.HasValue ? ToDecimal(a.Value) : (Decimal)0;
			public Decimal ToDecimal(Int16 a)  => Convert.ToDecimal(a);
			public Decimal ToDecimal(Int16? a) => a.HasValue ? ToDecimal(a.Value) : (Decimal)0;
			public Decimal ToDecimal(Char a) => Convert.ToDecimal(Convert.ToInt32(a));	// double -> Char throws exception
			public Decimal ToDecimal(Char? a) => a.HasValue ? ToDecimal(a.Value) : (Decimal)0;
			public Decimal ToDecimal(UInt32 a)  => Convert.ToDecimal(a);
			public Decimal ToDecimal(UInt32? a) => a.HasValue ? ToDecimal(a.Value) : (Decimal)0;
			public Decimal ToDecimal(UInt64 a)  => Convert.ToDecimal(a);
			public Decimal ToDecimal(UInt64? a) => a.HasValue ? ToDecimal(a.Value) : (Decimal)0;
			public Decimal ToDecimal(UInt16 a)  => Convert.ToDecimal(a);
			public Decimal ToDecimal(UInt16? a) => a.HasValue ? ToDecimal(a.Value) : (Decimal)0;
			public Decimal ToDecimal(Byte a)  => Convert.ToDecimal(a);
			public Decimal ToDecimal(Byte? a) => a.HasValue ? ToDecimal(a.Value) : (Decimal)0;
			public Decimal ToDecimal(Double a)  => Convert.ToDecimal(a);
			public Decimal ToDecimal(Double? a) => a.HasValue ? ToDecimal(a.Value) : (Decimal)0;
			public Decimal ToDecimal(Single a)  => Convert.ToDecimal(a);
			public Decimal ToDecimal(Single? a) => a.HasValue ? ToDecimal(a.Value) : (Decimal)0;
			public Decimal ToDecimal(Decimal a)  => Convert.ToDecimal(a);
			public Decimal ToDecimal(Decimal? a) => a.HasValue ? ToDecimal(a.Value) : (Decimal)0;

#endregion Decimal 		// Decimal 
	}
}