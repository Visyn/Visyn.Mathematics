#region Copyright (c) 2015-2017 Visyn
//The MIT License(MIT)
//
//Copyright(c) 2015-2017 Visyn
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:

//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.

//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.
#endregion
#region Autogenerated T4 Text Template
// Autogenerated from T4 Text Template :	DivideTests.tt
//											file:\C:\git\proto.temp\Visyn.Mathematics\Test\DivideTests.tt
// Autogeneration date/time:				8/13/2017 9:18:29 PM
#endregion

using System;
using System.Runtime.InteropServices;
using NUnit.Framework;
using Visyn.Mathematics.Rand;

namespace Visyn.Mathematics.Test
{
	public class DivTests
	{

	    /// <exception cref="Exception">May throw exception if exception handler not assigned.</exception>
        [Test()]
        public void DivTest_Int32()
        {
			var rangeMax =  Math.Min(1000000,Int32.MaxValue);
			IRandom random = Rng<FastRng>.Unique(null);
            var dividends = random.ExclusiveList(1, 100000,100);
            var divisors = random.ExclusiveList(1, 100000,100);

            for(int i=0;i<100;i++)
            {
                var remainder = (Int32)0;
                var dividend = (Int32)dividends[i];
                var divisor = (Int32)divisors[i];
				if(divisor == 0) divisor++;
                var ndividend = Negative<Int32>(dividend);
                var ndivisor = Negative<Int32>(divisor);

                var quotient = Numbers.Divide(dividend, divisor, out remainder);
                DivCheck(typeof(Int32),dividend, divisor, quotient, remainder, $"DivTest_Int32 (+/+) {dividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, divisor, out remainder);
                DivCheck(typeof(Int32),ndividend, divisor, quotient, remainder, $"DivTest_Int32 (-/+) {ndividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(dividend, ndivisor, out remainder);
                DivCheck(typeof(Int32),dividend, ndivisor, quotient, remainder, $"DivTest_Int32 (+/-) {dividend}/{ndivisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, ndivisor, out remainder);
                DivCheck(typeof(Int32),ndividend, ndivisor, quotient, remainder, $"DivTest_Int32 (-/-) {ndividend}/{ndivisor}={quotient} R {remainder}");
                
				Assert.Throws<DivideByZeroException>( delegate { Numbers.Divide(dividend, (Int32)0, out remainder); });
			}
        }


	    /// <exception cref="Exception">May throw exception if exception handler not assigned.</exception>
        [Test()]
        public void DivTest_Int64()
        {
			var rangeMax =  Math.Min(1000000,Int64.MaxValue);
			IRandom random = Rng<FastRng>.Unique(null);
            var dividends = random.ExclusiveList(1, 100000,100);
            var divisors = random.ExclusiveList(1, 100000,100);

            for(int i=0;i<100;i++)
            {
                var remainder = (Int64)0;
                var dividend = (Int64)dividends[i];
                var divisor = (Int64)divisors[i];
				if(divisor == 0) divisor++;
                var ndividend = Negative<Int64>(dividend);
                var ndivisor = Negative<Int64>(divisor);

                var quotient = Numbers.Divide(dividend, divisor, out remainder);
                DivCheck(typeof(Int64),dividend, divisor, quotient, remainder, $"DivTest_Int64 (+/+) {dividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, divisor, out remainder);
                DivCheck(typeof(Int64),ndividend, divisor, quotient, remainder, $"DivTest_Int64 (-/+) {ndividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(dividend, ndivisor, out remainder);
                DivCheck(typeof(Int64),dividend, ndivisor, quotient, remainder, $"DivTest_Int64 (+/-) {dividend}/{ndivisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, ndivisor, out remainder);
                DivCheck(typeof(Int64),ndividend, ndivisor, quotient, remainder, $"DivTest_Int64 (-/-) {ndividend}/{ndivisor}={quotient} R {remainder}");
                
				Assert.Throws<DivideByZeroException>( delegate { Numbers.Divide(dividend, (Int64)0, out remainder); });
			}
        }


	    /// <exception cref="Exception">May throw exception if exception handler not assigned.</exception>
        [Test()]
        public void DivTest_Int16()
        {
			var rangeMax =  Math.Min(1000000,Int16.MaxValue);
			IRandom random = Rng<FastRng>.Unique(null);
            var dividends = random.ExclusiveList(1, 100000,100);
            var divisors = random.ExclusiveList(1, 100000,100);

            for(int i=0;i<100;i++)
            {
                var remainder = (Int16)0;
                var dividend = (Int16)dividends[i];
                var divisor = (Int16)divisors[i];
				if(divisor == 0) divisor++;
                var ndividend = Negative<Int16>(dividend);
                var ndivisor = Negative<Int16>(divisor);

                var quotient = Numbers.Divide(dividend, divisor, out remainder);
                DivCheck(typeof(Int16),dividend, divisor, quotient, remainder, $"DivTest_Int16 (+/+) {dividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, divisor, out remainder);
                DivCheck(typeof(Int16),ndividend, divisor, quotient, remainder, $"DivTest_Int16 (-/+) {ndividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(dividend, ndivisor, out remainder);
                DivCheck(typeof(Int16),dividend, ndivisor, quotient, remainder, $"DivTest_Int16 (+/-) {dividend}/{ndivisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, ndivisor, out remainder);
                DivCheck(typeof(Int16),ndividend, ndivisor, quotient, remainder, $"DivTest_Int16 (-/-) {ndividend}/{ndivisor}={quotient} R {remainder}");
                
				Assert.Throws<DivideByZeroException>( delegate { Numbers.Divide(dividend, (Int16)0, out remainder); });
			}
        }


	    /// <exception cref="Exception">May throw exception if exception handler not assigned.</exception>
        [Test()]
        public void DivTest_Char()
        {
			var rangeMax =  Math.Min(1000000,Char.MaxValue);
			IRandom random = Rng<FastRng>.Unique(null);
            var dividends = random.ExclusiveList(1, 100000,100);
            var divisors = random.ExclusiveList(1, 100000,100);

            for(int i=0;i<100;i++)
            {
                var remainder = (Char)0;
                var dividend = (Char)dividends[i];
                var divisor = (Char)divisors[i];
				if(divisor == 0) divisor++;
                var ndividend = Negative<Char>(dividend);
                var ndivisor = Negative<Char>(divisor);

                var quotient = Numbers.Divide(dividend, divisor, out remainder);
                DivCheck(typeof(Char),dividend, divisor, quotient, remainder, $"DivTest_Char (+/+) {dividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, divisor, out remainder);
                DivCheck(typeof(Char),ndividend, divisor, quotient, remainder, $"DivTest_Char (-/+) {ndividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(dividend, ndivisor, out remainder);
                DivCheck(typeof(Char),dividend, ndivisor, quotient, remainder, $"DivTest_Char (+/-) {dividend}/{ndivisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, ndivisor, out remainder);
                DivCheck(typeof(Char),ndividend, ndivisor, quotient, remainder, $"DivTest_Char (-/-) {ndividend}/{ndivisor}={quotient} R {remainder}");
                
				Assert.Throws<DivideByZeroException>( delegate { Numbers.Divide(dividend, (Char)0, out remainder); });
			}
        }


	    /// <exception cref="Exception">May throw exception if exception handler not assigned.</exception>
        [Test()]
        public void DivTest_UInt32()
        {
			var rangeMax =  Math.Min(1000000,UInt32.MaxValue);
			IRandom random = Rng<FastRng>.Unique(null);
            var dividends = random.ExclusiveList(1, 100000,100);
            var divisors = random.ExclusiveList(1, 100000,100);

            for(int i=0;i<100;i++)
            {
                var remainder = (UInt32)0;
                var dividend = (UInt32)dividends[i];
                var divisor = (UInt32)divisors[i];
				if(divisor == 0) divisor++;
                var ndividend = Negative<UInt32>(dividend);
                var ndivisor = Negative<UInt32>(divisor);

                var quotient = Numbers.Divide(dividend, divisor, out remainder);
                DivCheck(typeof(UInt32),dividend, divisor, quotient, remainder, $"DivTest_UInt32 (+/+) {dividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, divisor, out remainder);
                DivCheck(typeof(UInt32),ndividend, divisor, quotient, remainder, $"DivTest_UInt32 (-/+) {ndividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(dividend, ndivisor, out remainder);
                DivCheck(typeof(UInt32),dividend, ndivisor, quotient, remainder, $"DivTest_UInt32 (+/-) {dividend}/{ndivisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, ndivisor, out remainder);
                DivCheck(typeof(UInt32),ndividend, ndivisor, quotient, remainder, $"DivTest_UInt32 (-/-) {ndividend}/{ndivisor}={quotient} R {remainder}");
                
				Assert.Throws<DivideByZeroException>( delegate { Numbers.Divide(dividend, (UInt32)0, out remainder); });
			}
        }


	    /// <exception cref="Exception">May throw exception if exception handler not assigned.</exception>
        [Test()]
        public void DivTest_UInt64()
        {
			var rangeMax =  Math.Min(1000000,UInt64.MaxValue);
			IRandom random = Rng<FastRng>.Unique(null);
            var dividends = random.ExclusiveList(1, 100000,100);
            var divisors = random.ExclusiveList(1, 100000,100);

            for(int i=0;i<100;i++)
            {
                var remainder = (UInt64)0;
                var dividend = (UInt64)dividends[i];
                var divisor = (UInt64)divisors[i];
				if(divisor == 0) divisor++;
                var ndividend = Negative<UInt64>(dividend);
                var ndivisor = Negative<UInt64>(divisor);

                var quotient = Numbers.Divide(dividend, divisor, out remainder);
                DivCheck(typeof(UInt64),dividend, divisor, quotient, remainder, $"DivTest_UInt64 (+/+) {dividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, divisor, out remainder);
                DivCheck(typeof(UInt64),ndividend, divisor, quotient, remainder, $"DivTest_UInt64 (-/+) {ndividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(dividend, ndivisor, out remainder);
                DivCheck(typeof(UInt64),dividend, ndivisor, quotient, remainder, $"DivTest_UInt64 (+/-) {dividend}/{ndivisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, ndivisor, out remainder);
                DivCheck(typeof(UInt64),ndividend, ndivisor, quotient, remainder, $"DivTest_UInt64 (-/-) {ndividend}/{ndivisor}={quotient} R {remainder}");
                
				Assert.Throws<DivideByZeroException>( delegate { Numbers.Divide(dividend, (UInt64)0, out remainder); });
			}
        }


	    /// <exception cref="Exception">May throw exception if exception handler not assigned.</exception>
        [Test()]
        public void DivTest_UInt16()
        {
			var rangeMax =  Math.Min(1000000,UInt16.MaxValue);
			IRandom random = Rng<FastRng>.Unique(null);
            var dividends = random.ExclusiveList(1, 100000,100);
            var divisors = random.ExclusiveList(1, 100000,100);

            for(int i=0;i<100;i++)
            {
                var remainder = (UInt16)0;
                var dividend = (UInt16)dividends[i];
                var divisor = (UInt16)divisors[i];
				if(divisor == 0) divisor++;
                var ndividend = Negative<UInt16>(dividend);
                var ndivisor = Negative<UInt16>(divisor);

                var quotient = Numbers.Divide(dividend, divisor, out remainder);
                DivCheck(typeof(UInt16),dividend, divisor, quotient, remainder, $"DivTest_UInt16 (+/+) {dividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, divisor, out remainder);
                DivCheck(typeof(UInt16),ndividend, divisor, quotient, remainder, $"DivTest_UInt16 (-/+) {ndividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(dividend, ndivisor, out remainder);
                DivCheck(typeof(UInt16),dividend, ndivisor, quotient, remainder, $"DivTest_UInt16 (+/-) {dividend}/{ndivisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, ndivisor, out remainder);
                DivCheck(typeof(UInt16),ndividend, ndivisor, quotient, remainder, $"DivTest_UInt16 (-/-) {ndividend}/{ndivisor}={quotient} R {remainder}");
                
				Assert.Throws<DivideByZeroException>( delegate { Numbers.Divide(dividend, (UInt16)0, out remainder); });
			}
        }


	    /// <exception cref="Exception">May throw exception if exception handler not assigned.</exception>
        [Test()]
        public void DivTest_Byte()
        {
			var rangeMax =  Math.Min(1000000,Byte.MaxValue);
			IRandom random = Rng<FastRng>.Unique(null);
            var dividends = random.ExclusiveList(1, 100000,100);
            var divisors = random.ExclusiveList(1, 100000,100);

            for(int i=0;i<100;i++)
            {
                var remainder = (Byte)0;
                var dividend = (Byte)dividends[i];
                var divisor = (Byte)divisors[i];
				if(divisor == 0) divisor++;
                var ndividend = Negative<Byte>(dividend);
                var ndivisor = Negative<Byte>(divisor);

                var quotient = Numbers.Divide(dividend, divisor, out remainder);
                DivCheck(typeof(Byte),dividend, divisor, quotient, remainder, $"DivTest_Byte (+/+) {dividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, divisor, out remainder);
                DivCheck(typeof(Byte),ndividend, divisor, quotient, remainder, $"DivTest_Byte (-/+) {ndividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(dividend, ndivisor, out remainder);
                DivCheck(typeof(Byte),dividend, ndivisor, quotient, remainder, $"DivTest_Byte (+/-) {dividend}/{ndivisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, ndivisor, out remainder);
                DivCheck(typeof(Byte),ndividend, ndivisor, quotient, remainder, $"DivTest_Byte (-/-) {ndividend}/{ndivisor}={quotient} R {remainder}");
                
				Assert.Throws<DivideByZeroException>( delegate { Numbers.Divide(dividend, (Byte)0, out remainder); });
			}
        }


	    /// <exception cref="Exception">May throw exception if exception handler not assigned.</exception>
        [Test()]
        public void DivTest_Double()
        {
			var rangeMax =  Math.Min(1000000,Double.MaxValue);
			IRandom random = Rng<FastRng>.Unique(null);
            var dividends = random.ExclusiveList(1, 100000,100);
            var divisors = random.ExclusiveList(1, 100000,100);

            for(int i=0;i<100;i++)
            {
                var remainder = (Double)0;
                var dividend = (Double)dividends[i];
                var divisor = (Double)divisors[i];
				if(divisor == 0) divisor++;
                var ndividend = Negative<Double>(dividend);
                var ndivisor = Negative<Double>(divisor);

                var quotient = Numbers.Divide(dividend, divisor, out remainder);
                DivCheck(typeof(Double),dividend, divisor, quotient, remainder, $"DivTest_Double (+/+) {dividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, divisor, out remainder);
                DivCheck(typeof(Double),ndividend, divisor, quotient, remainder, $"DivTest_Double (-/+) {ndividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(dividend, ndivisor, out remainder);
                DivCheck(typeof(Double),dividend, ndivisor, quotient, remainder, $"DivTest_Double (+/-) {dividend}/{ndivisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, ndivisor, out remainder);
                DivCheck(typeof(Double),ndividend, ndivisor, quotient, remainder, $"DivTest_Double (-/-) {ndividend}/{ndivisor}={quotient} R {remainder}");
                
				Assert.Throws<DivideByZeroException>( delegate { Numbers.Divide(dividend, (Double)0, out remainder); });
			}
        }


	    /// <exception cref="Exception">May throw exception if exception handler not assigned.</exception>
        [Test()]
        public void DivTest_Single()
        {
			var rangeMax =  Math.Min(1000000,Single.MaxValue);
			IRandom random = Rng<FastRng>.Unique(null);
            var dividends = random.ExclusiveList(1, 100000,100);
            var divisors = random.ExclusiveList(1, 100000,100);

            for(int i=0;i<100;i++)
            {
                var remainder = (Single)0;
                var dividend = (Single)dividends[i];
                var divisor = (Single)divisors[i];
				if(divisor == 0) divisor++;
                var ndividend = Negative<Single>(dividend);
                var ndivisor = Negative<Single>(divisor);

                var quotient = Numbers.Divide(dividend, divisor, out remainder);
                DivCheck(typeof(Single),dividend, divisor, quotient, remainder, $"DivTest_Single (+/+) {dividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, divisor, out remainder);
                DivCheck(typeof(Single),ndividend, divisor, quotient, remainder, $"DivTest_Single (-/+) {ndividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(dividend, ndivisor, out remainder);
                DivCheck(typeof(Single),dividend, ndivisor, quotient, remainder, $"DivTest_Single (+/-) {dividend}/{ndivisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, ndivisor, out remainder);
                DivCheck(typeof(Single),ndividend, ndivisor, quotient, remainder, $"DivTest_Single (-/-) {ndividend}/{ndivisor}={quotient} R {remainder}");
                
				Assert.Throws<DivideByZeroException>( delegate { Numbers.Divide(dividend, (Single)0, out remainder); });
			}
        }


	    /// <exception cref="Exception">May throw exception if exception handler not assigned.</exception>
        [Test()]
        public void DivTest_Decimal()
        {
			var rangeMax =  Math.Min(1000000,Decimal.MaxValue);
			IRandom random = Rng<FastRng>.Unique(null);
            var dividends = random.ExclusiveList(1, 100000,100);
            var divisors = random.ExclusiveList(1, 100000,100);

            for(int i=0;i<100;i++)
            {
                var remainder = (Decimal)0;
                var dividend = (Decimal)dividends[i];
                var divisor = (Decimal)divisors[i];
				if(divisor == 0) divisor++;
                var ndividend = Negative<Decimal>(dividend);
                var ndivisor = Negative<Decimal>(divisor);

                var quotient = Numbers.Divide(dividend, divisor, out remainder);
                DivCheck(typeof(Decimal),dividend, divisor, quotient, remainder, $"DivTest_Decimal (+/+) {dividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, divisor, out remainder);
                DivCheck(typeof(Decimal),ndividend, divisor, quotient, remainder, $"DivTest_Decimal (-/+) {ndividend}/{divisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(dividend, ndivisor, out remainder);
                DivCheck(typeof(Decimal),dividend, ndivisor, quotient, remainder, $"DivTest_Decimal (+/-) {dividend}/{ndivisor}={quotient} R {remainder}");

                quotient = Numbers.Divide(ndividend, ndivisor, out remainder);
                DivCheck(typeof(Decimal),ndividend, ndivisor, quotient, remainder, $"DivTest_Decimal (-/-) {ndividend}/{ndivisor}={quotient} R {remainder}");
                
				Assert.Throws<DivideByZeroException>( delegate { Numbers.Divide(dividend, (Decimal)0, out remainder); });
			}
        }

	    private static Int64 Cast64<T>(T value) where T : IConvertible
        {
            var quotientDouble = Convert.ToDouble(value);
            Int64 quotient64 = Convert.ToInt64(quotientDouble > 0 ? Math.Floor(quotientDouble) : Math.Ceiling(quotientDouble));
            return quotient64;
        }

		private static void DivCheck<T>(Type type, T dividend, T divisor, T quotientT, T remainder, string message) where T : IConvertible
		{
		    //Int64 quotient64 = quotient > 0 ? Math.Floor(quotient) : Math.Ceiling(quotient);
		    var quotientDouble = Convert.ToDouble(quotientT);
		    Int64 quotient64 = Cast64<T>(quotientT);
            double calculated = Convert.ToDouble(dividend) / Convert.ToDouble(divisor);
			double tolerance = Math.Abs(calculated*Math.Pow(2, Marshal.SizeOf(type) * -2)*10);
			Assert.AreEqual(quotient64, Cast64<double>(calculated), tolerance, message);
            Assert.AreEqual(quotient64 + (Convert.ToDouble(remainder) / Convert.ToDouble(divisor)), calculated, tolerance,message);
        }


		private static void DivCheck(Type type, char dividend, char divisor, char quotient, char remainder, string message) //where T : IConvertible
        {
            double calculated = (double)dividend / (double)divisor;
            double tolerance = Math.Abs(calculated * Math.Pow(2, Marshal.SizeOf(type) * -2) * 10);
            Assert.AreEqual(Convert.ToInt64(quotient), (Int64)calculated, tolerance, message);
            Assert.AreEqual((double)quotient + (double)remainder / (double)divisor, calculated, tolerance, message);
        }

		private Int32 Negative<T>(Int32 value) { return (Int32)(value*-1); }
		private Int64 Negative<T>(Int64 value) { return (Int64)(value*-1); }
		private Int16 Negative<T>(Int16 value) { return (Int16)(value*-1); }
		private Char Negative<T>(Char value) { return (Char)(value*-1); }
		private UInt32 Negative<T>(UInt32 value) { return (UInt32)(value); }
		private UInt64 Negative<T>(UInt64 value) { return (UInt64)(value); }
		private UInt16 Negative<T>(UInt16 value) { return (UInt16)(value); }
		private Byte Negative<T>(Byte value) { return (Byte)(value); }
		private Double Negative<T>(Double value) { return (Double)(value*-1); }
		private Single Negative<T>(Single value) { return (Single)(value*-1); }
		private Decimal Negative<T>(Decimal value) { return (Decimal)(value*-1); }
	}
}




